/*
 * Zzish JavaScript SDK
 *
 */

module.exports = Proxy;
var storage = require('./storage');
if (typeof window === 'undefined') {
	// running in node so use https://www.npmjs.org/package/xmlhttprequest
	XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;
}


function Proxy(config) {
	if (config.debug) console.log('Proxy instanciated, config:', config);
	this.config = config;
}

Proxy.prototype.ajax = function(request, callback, module) {
	console.log('request data' + JSON.stringify(request.data));
	var debug = this.config.debug, req;
	addAppId(request.data, this.config.appId);
	//addAuthToken(request.data, this.config.authToken);
	//addUserId(request.data, this.config.userId);
	

	if (debug) console.log('Proxy.ajax', JSON.stringify(request));
	if (typeof request.method === 'undefined') {
		request.method = this.config.ajax.method;
	}
	if (this.config.batch.enabled === false) {
		req = new XMLHttpRequest();

		

		req.addEventListener('load', function() {
					response(this, callback, debug);
			}, false);
		req.addEventListener('error', function(){
				error(this, callback, debug);
			}, false);
		req.open(request.method, request.url, true);

		req.setRequestHeader('X-ApplicationId', this.config.appId);
		req.setRequestHeader('Content-Type', 'application/json');
		
		if (debug) console.log('Proxy.ajax send', request.method, request.url, request.data);
		req.send(JSON.stringify(request.data));
			} else {
		this.batchAjax(request, callback, module);
	}
}

Proxy.prototype.buildUrl = function () {
	var result = this.config.baseUrl;
	for (var i=0, l = arguments.length; i < l; i++){
		result += '/' + arguments[i];
	}
	return result;
}

Proxy.prototype.batchAjax = function(request, callback, module) {
	var batchCfg = this.config.batch[module], now = Date.now(), item, state;
	if (typeof batchCfg === 'undefined') {
		console.log('Module', module, 'not configured for batch');
		this.proxy.ajax(request, callback);
	} else {
		state = storage.state(module);
		if ((now >= state.lastSend + batchCfg.reapTime) || 
				(state.itemCount >= batchCfg.itemCount) ) {
				console.log ('Sending requests for', module, 'conditions reached');
				for (var key in state.keys) {
					item = storage.getItem(key);
					this.ajax(item.request, item.callback);
					storage.removeItem(key);
				}
		} else {
			console.log('Adding request', request, 'to queue');
			storage.addItem(module, request, callback);
		}
	}
};

function response(resp, callback, debug) {
	var err = null, res = null;
	try {
		if (resp.status >= 200 && resp.status < 300) {
			res = JSON.parse(resp.responseText);
		} else {
			err = JSON.parse(resp.responseText);
		}
	} catch (e) {
		err = resp.responseText;
	}
	if (debug) console.log('Proxy.response callback', err,res);
	if (typeof callback === 'function') {
		callback (err, res);
	}
}

function addXApplicationId(request){
	request.setRequestHeader('X-ApplicationId', request.id);
	return request;
}

function error(evt, callback, debug) {
	if (debug) console.log('Proxy.error', JSON.stringify(evt));
	callback(evt.currentTarget, null);
}

function addAppId (toObj, appId){
	if (typeof toObj.appId === 'undefined') {
		toObj.appId = appId;
	}
}

function addAuthToken (toObj, authToken){
	if (typeof toObj.authToken != 'undefined') {
		toObj.authToken = authToken;
	}
}

function addUserId (toObj, userId){
	if (typeof toObj.userId === 'undefined') {
		toObj.userId = userId;
	}
}